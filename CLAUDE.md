# 言語
- 日本語でコミュニケーションしてください。
- ファイルに日本語を書き込む場合は、文字化けしないようにutf8で記述してください。

# 厳守すべきこと
- SOLID原則に基づいた設計にすること
- YAGNI原則に基づき、必要最小限の対応に留めること
- KISS原則に基づき、極力シンプルな設計を徹底すること
- DRY原則に基づき、同じことを繰り返し実装することはしないこと
- 後方互換生は指定された時のみ考慮し、そうでない場合は考慮しないこと
  - あるべき状態の担保を優先すること

# プラン
- プランニングする際はその結果をmdファイルとして出力するようにすること
- 出力先はプロジェクトのルートディレクトリ上の `plan.md` に保存すること
- プランニング内容に「~を確認する」というタスクを残さないこと。確認するタスクはプランニング時点で終わらせておくこと
- 基盤レベルの実装を行う際は、必ず最新の技術トレンドやベストプラクティスに則っているかを確認した上で設計を行うこと

# ClaudeCodeでのタスクの実行
- Todoのタスクが1つ終わるたびに、sayコマンドを実行して進捗率を音声出力してください
  - 発話のスピードは200にしてください（ex. `say -r 200`）
  - この時、具体的にどんなタスクが終わったのかをメッセージ内容から分かるように、簡潔な1文にしてください 
  - また、現在の進捗率についても都度教えてください
  - SubAgentを利用した場合は、どのSubAgentを使ったかも教えてください

# 実装時に**必ず**守るべき事項
- 無闇にフォールバック処理を実装しないこと
  - 極力根本的な対応をその場でしてしまうことを心がけること
- コーディングを行う際は同じような実装パターンがないかを事前に確認し、プロジェクト全体で一貫したコードスタイルになることを心がけること
- コメントは、「なぜそうしているか」についてのみ記載すること
  - 「何をしているか」を都度コメントで書くことはしないこと（コメントではなく、プログラムコードでそれがわかるような命名をすること）
- 無闇にログ出力の処理を増やさないこと
  - 明確な目的がある場合のみ実装すること
- ErrorやWarningを残した状態でタスクを終わらせないこと
  - ちゃんと問題に対して適切な根本解決をして対応を終わらせること
- コードの修正を行った後は、プロジェクト全体で型エラーなどが発生していないかチェックすること
  - もしエラーが発生している箇所があれば必ず対象部分の修正も行うこと
- AIの作業ログを実装ファイル内にコメントとして残さないこと

# 技術選定
- 必ず最新の技術トレンドやベストプラクティスを確認した上で選定を行うこと
- ライブラリの導入時には依存関係による問題などがない限りは、基本的に最新のバージョンを利用することを徹底すること

## 特定領域毎の遵守すべき事項

#### TypeScript
- any型は、どうしても使わなければならないケースの場合以外は利用しないこと
  - その上で使う場合は、理由をコメントで必ず残しておくこと
- publicな定義を前方に配置し、privateな定義は後方に配置すること

#### Dart
- 引数のパラメータは原則 `required` を付けてOptionalにはしないこと
  - 指定忘れによるバグが多発するため
- 高階関数を用いた関数型プログラミングのスタイルを優先すること
  - if, forなどの制御構文は極力使わないこと

#### Swift
- 高階関数を用いた関数型プログラミングのスタイルを優先すること
  - if, forなどの制御構文は極力使わないこと
- completionHandler形式の非同期ハンドリングはせず、async/awaitを活用すること
  - ネストを小さくして処理の流れが捉えやすくなる
  - エラーハンドリングがシンプルになる
  - 同期・非同期の切り替えや、キャンセルや構造化非同期処理との親和性が高い
- `self` を省略できる箇所は省略する
- `return` を省略できる箇所は省略する
- `if` や `switch` など、式として扱えるケースはそれを優先する
- 型を推論させられるケースは、明示的な型指定は行わずに、推論させること

#### SwiftTesting

- 前提条件は #require、検証は #expect に分離すること
- パラメータ化で効率化できる部分があれば積極的に使うこと
  ```
  # パラメータ化
  ```swift
  @Test(arguments: [1, 2, 3])
  func square(_ x: Int) {
    #expect(x * x >= x)
  }

  @Test(arguments: [("ja", "こんにちは"), ("en", "hello")])
  func localized(_ lang: String, _ expected: String) {
    #expect(greeting(lang) == expected)
  }
  ```

  同じテストロジックを、入力（引数）だけ変えて繰り返し実行する仕組み。`@Test(arguments: [...])` にケースを列挙すると、その分だけ個別のテストとして展開・集計されます。

  ```swift
  // async throws と併用した例
  @Test(arguments: ["a", "b", "c"])
  func fetchUser_roundTrip(_ id: String) async throws {
    let user = try await API().fetchUser(id: id)
    #expect(user.id == id)
  }
  ```

  - 入力ごとに独立したテストとして表示・集計されます。
  - `arguments` の要素がタプルの場合、テスト関数の複数引数に対応して束縛されます。
  - `async`/`throws` のテストでもそのまま利用できます。
  ```

#### iOS
- ファイルの追加・削除・移動を行なった場合は、Xcodeのプロジェクトファイルの変更も必ず行うこと
  - 単にファイル操作しただけでは、Xcodeでビルドする際に認識されないため
- サポートOSの制限を考慮した上で、極力モダンなAPIや技術を活用すること

# テスト

## UnitTest
- UnitTestはあるべきの状態をテストケースとして実装し、現状の実装に対してテストが通るようなものに合わせることは絶対にしないこと
  - テストが失敗したとき
    - それは実装がおかしいので、テストを通すためにテスト実装を修正することはしないこと
    - 実装の修正は別のスコープ・タスクで行うこと
      - 実装の修正も合わせて行うよりも、まずは「現状失敗している」ということが大事であること理解すること